;PROGRAM SURVEY.ASM
;ASSEMBLE WITH DRI 'MAC' MACRO ASSEMBLER
;PROGRAM PRINTS SYSTEM SURVEY ON CRT/PRINTER
;DISASSEMBLED AND CONVERTED 21 NOV 84 RHP


	ORG	00100H

BDOS	EQU	00005H		;LOCATION OF BDOS POINTER
BDOSH	EQU	BDOS+1		;HI BYTE OF BDOS ADDRESS
BDOSA	EQU	BDOS+2		;BDOS ADDRESS

;BDOS CALLS

CONOUT	EQU	002H		;BDOS CALLS
VERSION	EQU	00CH		;RETURN VERSION NUMBER
SELDSK	EQU	00EH		;SELECT DISK
FRSTFL	EQU	011H		;RETURN FIRST FILE
NEXTFL	EQU	012H		;NEXT FILE
LOGIN	EQU	018H		;DISKS LOGGED IN
CDISK	EQU	019H		;GET CURRENT DISK IN HL
ALLOC	EQU	01BH		;DISK ALLOCATION ADDRESS
ROBITS	EQU	01DH		;GET DISK READ ONLY BITS IN HL
DPBADR	EQU	01FH		;DISK PARAMETER BLOCK ADDRESS
USRCOD	EQU	020H		;GET USER CODE IN A

ZERO	EQU	0000H
CR	EQU	00DH		;CARRIAGE RETURN
CRHI	EQU	08DH		;CR WITH HI BIT SET
LF	EQU	00AH		;LINE FEED
LFHI	EQU	08AH		;LINE FEED WITH HI BIT SET
TAB	EQU	009H		;TAB
COLON	EQU	03AH		;COLON
BAR	EQU	07CH		;VERTICAL BAR
TABHI	EQU	089H		;TAB WITH HI BIT SET
SPACHI	EQU	0A0H		;SPACE WITH HI BIT SET
DOTHI:	EQU	0AEH		;. WITH HI BIT SET
CHI	EQU	0C3H		;C WITH HI BIT SET
MHI	EQU	0CDH		;M WITH HI BIT SET
RHI	EQU	0D2H		;R WITH HI BIT SET
THI	EQU	0D4H		;T WITH HI BIT SET

	MACLIB	Z80

ENTRY:	LXI	H,ZERO		;CLEAR HL
	DAD	SP		;MOVE OLD STACK TO HL
	SHLD	OSTACK		;SAVE OLD STACK
	LXI	SP,STACK	;START NEW STACK

	CALL	PRINT		;CLEAN SCREEN
	DB	CR, LF,LF,LF,LF,LF,LF,LF,LF,LF
	DB	LF,LF,LF,LF,LF,LF,LF,LFHI

	CALL	PRINT		;PRINT BANNER
	DB	TAB, TAB, TAB
	DB	'*** RC2014 SYSTEM SURVEY ***'
	DB	CR, LF, CR, LFHI

	LXI	H,00008H
	MVI	C,LOGIN
	PUSH	H
	CALL	BDOS		;RETURN LOGIN BITS IN HL,BA
	POP	H
LOGIN1:	RAR
	JNC	DSKSP1
	PUSH	PSW
	PUSH	H

	CALL	PRINT		
	DB	'Drive', SPACHI		

	MVI	A,'A' 		;CONV DISK FROM BIN TO ASCII
	ADD	H
	MOV	E,A
	CALL	PCONS		;PRINT LOGGED ON DISK

	CALL	PRINT		
	DB	COLON, SPACHI	

;CALCULATE SIZE OF DISK AND PRINT SIZE IN DECIMAL


DSKSZ:	POP	H
	PUSH	H
	MOV	E,H
	MVI	C,SELDSK
	CALL	BDOS		;SELECT INDICATED DISK

	MVI	C,ALLOC
	CALL	BDOS		;RETURN ALLOC VECT ADDR IN HL

	MOV	L,A
	MOV	H,B
	PUSH	H		;SAVE ALLOC VECT ADDR
	MVI	C,VERSION
	CALL	BDOS		;RET VERS NO. IN HL,BA

	MOV	A,L
	ORA	A
	JNZ	VNOT0

	LHLD	BDOSH		;IF VERSION 0
	MVI	L,03CH
	MOV	A,M
	STA	STOR4
	INX	H
	INX	H
	MOV	L,M
	MVI	H,ZERO
	SHLD	STOR5
	MVI	B,020H
	JMP	JOINV0

VNOT0:	MVI	A,03FH		;VERSION NOT 0
	STA	STOR1
	MVI	C,DPBADR
	CALL	BDOS		;GET DBP ADDR IN HL

	INX	H
	INX	H
	MOV	A,M
	STA	STOR4
	INX	H
	INX	H
	INX	H
	MOV	A,M
	INX	H
	MOV	H,M
	MOV	L,A
	SHLD	STOR5
	INX	H
	MVI	B,003H
RRHLN:	MOV	A,H
	ORA	A
	RAR
	MOV	H,A
	MOV	A,L
	RAR
	MOV	L,A
	DCR	B
	JNZ	RRHLN
	MOV	B,L
	LDA	STOR5
	ANI	003H
	JZ	JOINV0
	INR	B

JOINV0:	POP	H
	LXI	D,ZERO
JOINV1:	MVI	C,008H
	MOV	A,M
JOINV2:	RAR
	JNC	JOINV3
	INX	D
JOINV3:	DCR	C
	JNZ	JOINV2
	INX	H
	DCR	B
	JNZ	JOINV1
	CALL	WHAT
	PUSH	H
	CALL	BINDEC		;PRINT SIZE OF DISK

	CALL	PRINT	
	DB	'K bytes in', SPACHI


;CALCULATE THE NUMBER OF FILES AND PRINT IN DECIMAL 

	LXI	D,STOR1
	MVI	C,FRSTFL
	CALL	BDOS		;GET FCB OF FIRST FILE 
				;IN HL AND DIR CODE IN A

	LXI	H,ZERO
NXFILE:	CPI	0FFH		;LAST FILE?
	JZ	LSFILE
	ADD	A
	ADD	A
	ADD	A
	ADD	A
	ADD	A
	ADI	080H
	MOV	E,A
	MVI	D,ZERO
	LDAX	D
	CPI	0E5H
	JZ	NXFIL1
	INX	H
NXFIL1:	LXI	D,STOR1
	MVI	C,NEXTFL
	PUSH	H
	CALL	BDOS		;GET FCB ADDR OF NEXT FILE 
				;IN HL AND DIR CODE IN A
	POP	H
	JMP	NXFILE

LSFILE:	CALL	BINDEC		;PRINT NUMBER OF FILES

	CALL	PRINT		
	DB	' files with', SPACHI

;CALCULATE REMAINING DISK SPACE AND PRINT IN DECIMAL

	LHLD	STOR5
	XCHG
	INX	D
	CALL	WHAT
	XCHG
	POP	H
	MOV	A,H
	CMA
	MOV	H,A
	MOV	A,L
	CMA
	MOV	L,A
	INX	H
	DAD	D
	CALL	BINDEC		;PRINT DISK SPACE LEFT

	CALL	PRINT		
	DB	'K bytes remaining', CR, LFHI

	POP	H
	POP	PSW
DSKSP1:	INR	H
	DCR	L
	JNZ	LOGIN1

	CALL	PRINT		;PRINT MEMORY SCALE
	DB	CR, LF, 'MEMORY MAP:', CR, LF
	DB	'0',TAB,'8',TAB,'16',TAB,'24',TAB,'32'
	DB	TAB,'40',TAB,'48',TAB,'56',TAB,'64'
	DB	CR,LF,BAR,TAB,BAR,TAB,BAR,TAB,BAR,TAB
	DB	BAR,TAB,BAR,TAB,BAR,TAB,BAR,TAB,BAR
	DB	CR, LF, THI	


; EVALUATE THE MEMORY IN 1K BLOCKS AND PRINT T,C,M,OR NONE

	LXI  	H,RAMSZ 
	MVI	M,0FFH
	INX	H
	MVI	M,003H
	MVI	B,004H
MEMT1:	INX	H
	MVI	M,ZERO
	DCR	B
	JNZ	MEMT1
	LXI	H,TEST1
	MVI	C,03FH
MEMT2:	LXI	D,TEST1
	XRA	A
	STA	STOR2
	STA	STOR3
MEMT3:	MOV	A,M
	MOV	B,A
	CMA
	MOV	M,A
	SUB	M
	MOV	M,B
	JNZ	MEMT5
	PUSH	H
	LXI	H,RAMSZ
	INR	M
	JNZ	MEMT4
	INX	H
	INR	M
MEMT4:	POP	H
	JMP	TPAM3

MEMT5:	STA	STOR2
	MVI	A,0FFH
	SUB	B
	JNZ	TPAMEM
	LDA	STOR3
	ANA	A
	JZ	TPAM3
	JMP	TPAM1

TPAMEM:	STA	STOR3
TPAM1:	PUSH	H
	LXI	H,ROMSZ
	INR	M
	JNZ	TPAM2
	INX	H
	INR	M
TPAM2:	POP	H
TPAM3:	INX	H
	DCX	D
	XRA	A
	ORA	D
	ORA	E
	JNZ	MEMT3
	PUSH	B
	PUSH	H
	LDA	STOR2
	ANA	A
	JNZ	ROMEM
	LDA	BDOSA
	DCR	H
	CMP	H
	JC	CPMEM

	CALL	PRINT		;T FOR TPA (RAM) AREA
	DB	THI		

	JMP  	MORMEM 

CPMEM:	ADI	014H
	JNC	CPMTS
	MVI	A,0FFH
CPMTS:	CMP	H
	JC	RAMEM

	CALL	PRINT		;PRINT C FOR CPM AREA
	DB	CHI

	JMP	MORMEM

RAMEM:	CALL	PRINT		;PRINT M FOR UNASSIGNED MEMORY
	DB  	MHI 	

	JMP 	MORMEM

ROMEM:	LDA	STOR3
	ANA	A
	JZ	NOMEM

	CALL	PRINT 		;PRINT R FOR ROM MEMORY
	DB	RHI	

	JMP 	MORMEM

NOMEM:	CALL	PRINT		;PRINT DOT FOR MISSING
	DB	DOTHI		

MORMEM:	POP	H
	POP	B
	DCR	C
	JNZ	MEMT2

	CALL	PRINT		;PRINT EXPLAINATION
	DB	CR, LF, CR, LF, 'T=TPA', TAB, 'C=CPM'
	DB	TAB, 'M=Unassigned Memory', TAB
	DB	'R=ROM or Bad Memory', CR, LF, CR, LFHI

;GET SIZE OF RAM AND PRINT IN DECIMAL

	LHLD	RAMSZ		;GET RAM SIZE
	PUSH	H		;SAVE RAM SIZE
	CALL	BINDEC		;PRINT RAM SIZE

	CALL	PRINT		
	DB	' Bytes RAM', TAB, TABHI

;GET SIZE OF ROM AND PRINT IN DECIMAL

	LHLD	ROMSZ		;GET ROM SIZE
	PUSH	H		;SAVE ROM SIZE
	CALL	BINDEC		;PRINT SIZE OF ROM

	CALL	PRINT	
	DB	' Bytes ROM', TAB, TABHI

;GET SIZE OF TPA AND PRINT IN DECIMAL

	LHLD	BDOSH		;POINT TO BDOS IN K
	CALL	BINDEC		;PRINT TPA SIZE

	CALL	PRINT	
	DB	' Bytes in TPA', CR, LFHI

;CALCULATE SIZE OF UNIMPLEMENTED MEMORY AND PRINT IN DECIMAL

	POP	D		;GET ROM SIZE
	POP	H		;GET RAM SIZE
	DAD	D		;ADD FOR TOTAL MEMORY SIZE
	PUSH	H		;SAVE TOTAL MEMORY SIZE
	LXI	D,ZERO
	MOV	A,H		;COMPLEMENT MEMORY SIZE
	CMA
	MOV	H,A
	MOV	A,L
	CMA
	MOV	L,A
	DAD	D		;SUBTRACT USED SIZE FROM MEM SPACE
	CALL	BINDEC		;PRINT EMPTY BYTES

	CALL	PRINT	
	DB	' Bytes Empty   ', TABHI

;GET TOTAL MEMORY SIZE AND PRINT IN DECIMAL

	POP	H		;REGAIN TOTAL MEMORY SIZE 
	CALL	BINDEC		;PRINT MEMORY SIZE

	CALL	PRINT	
	DB	' Total Active Bytes', CR, LF, CR, LF
	DB	'ACTIVE '
TEST1:	DB	'I/O PORTS', CR, LFHI

;DETERMINE ACTIVE I/O PORTS AND PRINT THEM OUT IN HEX

	LXI	H,01000H
IODLY:	DCX	HL
	MOV	A,H
	ORA	L
	JNZ	IODLY

	LXI	H,ZERO		;H SUMS THE NO OF IO PORTS
	LXI	D,00009H
IOLOOP:	MOV	A,D
	CPI	030H		;SKIP 30-3F
	JZ	SKIP
	CPI	031H
	JZ	SKIP
	CPI	032H
	JZ	SKIP
	CPI	033H
	JZ	SKIP
	CPI	034H
	JZ	SKIP
	CPI	035H
	JZ	SKIP
	CPI	036H
	JZ	SKIP
	CPI	037H
	JZ	SKIP
	CPI	038H
	JZ	SKIP
	CPI	039H
	JZ	SKIP
	CPI	03AH
	JZ	SKIP
	CPI	03BH
	JZ	SKIP
	CPI	03CH
	JZ	SKIP
	CPI	03DH
	JZ	SKIP
	CPI	03EH
	JZ	SKIP
	CPI	03FH
	JZ	SKIP
	CPI	0B0H		;SKIP B0-BF
	JZ	SKIP
	CPI	0B1H
	JZ	SKIP
	CPI	0B2H
	JZ	SKIP
	CPI	0B3H
	JZ	SKIP
	CPI	0B4H
	JZ	SKIP
	CPI	0B5H
	JZ	SKIP
	CPI	0B6H
	JZ	SKIP
	CPI	0B7H
	JZ	SKIP
	CPI	0B8H
	JZ	SKIP
	CPI	0B9H
	JZ	SKIP
	CPI	0BAH
	JZ	SKIP
	CPI	0BBH
	JZ	SKIP
	CPI	0BCH
	JZ	SKIP
	CPI	0BDH
	JZ	SKIP
	CPI	0BEH
	JZ	SKIP
	CPI	0BFH
	JZ	SKIP
	CPI	09FH
	JZ	SKIP
	CPI	0FCH		;SKIP OVER WAIT PORT
	JZ	SKIP
	STA	PORT+1
PORT:	IN	0	
	CPI	0FFH		;ALL DONE?
	JZ	NXTIO
SKIP:	MOV	A,D
	PUSH	D
	PUSH	H
	JMP	ENDLN


;CONVERT BINARY PORT NO TO HEX AND PRINT

BINHEX:	PUSH	PSW
	RRC
	RRC
	RRC
	RRC
	CALL	BNHX1
	POP	PSW
BNHX1:	ANI	00FH
	ADI	090H
	DAA
	ACI	040H
	DAA
	MOV	E,A
	MVI	C,CONOUT
	JMP	BDOS		;PRINT PORT NO IN HEX

ENDLN:	CALL	BINHEX
	POP	H
	POP	D
	INX	H
	DCR	E
	JNZ	TABIO

	MVI	E,TAB		;PRINT TAB, CRLF
	CALL	PRINT
 	DB	CR,LFHI		

	JMP	NXTIO

TABIO:	CALL	PRINT		;PRINT TAB
	DB	TABHI		

NXTIO:	INR	D
	JNZ	IOLOOP

	CALL	PRINT
	DB	CR, LFHI

	CALL	BINDEC		;PRINT NO OF ACTIVE PORTS

	CALL	PRINT
	DB	' Ports active', CR, LFHI

	CALL	PRINT 		;PRINT CCP MSG
	DB	'CCP starts at',SPACHI

	LHLD	BDOSH 		;GET BDOS ADDRESS
	MOV	A,L
	SBI	006H		;SUBTRACT BDOS ENTRY OFFSET
	MOV	L,A
	SHLD	SBDOS    	;SAVE BDOS ADDR
	LXI	D,0F700H	;- CCP SIZE & BASE PAGE
	DAD	D		;SUBTRACT CCP & BASE PAGE	     
	SHLD	STPA    	;SAVE THE TPA SIZE
	LXI	D,ENTRY		;BASE PAGE SIZE
	DAD	D		;ADD BP TO TPA TO GET CCP ADDR	     
	CALL	HLHEX		;PRINT CCP ADDR IN HEX

	CALL	PRINT 		;PRINT BDOS MSG
	DB	'    BDOS starts at',SPACHI

	LHLD	SBDOS 		;RECOVER BDOS ADDR
	CALL	HLHEX		;PRINT BDOS ADDR IN HEX

 	CALL	PRINT 		;PRINT BIOS MSG
	DB	'    BIOS starts at',SPACHI

	LXI	D,00E00H	;LENGTH OF BDOS
	LHLD	SBDOS 		;GET BDOS START ADDR
	DAD	D	     	;FIGURE BDOS END ADDR
	CALL	HLHEX		;PRINT BIOS ADDR IN HEX
	CALL	CRLFD		;PRINT CR/LF

	CALL	PRINT 		;PRINT TPA MSG
	DB	'Available TPA without killing the CCP is',SPACHI

	LHLD	STPA 		;RECOVER TPA SIZE
	CALL	HLHEX		;PRINT TPA SIZE IN HEX

	CALL	PRINT 		;PRINT 'BYTES'
	DB	' bytes ',CR,LFHI

	CALL	PRINT 		;PRINT ALLOC VECTOR MSG
	DB	'The Allocation address of drive ',SPACHI

	MVI	C,CDISK
	CALL	BDOS
	ADI	'A'
	CALL	HXPRT		;PRINT CURRENT DISK
	CALL	PRINT 
	DB	': is',SPACHI

	MVI	C,ALLOC		;GET THE DISK ALLOC BLOCK ADDR
	CALL	BDOS 
	CALL	HLHEX		;PRINT ALLOC ADDR
	MVI	A,'H' 
	CALL	HXPRT		;PRINT H
	CALL	CRLFD

	CALL	PRINT 		;PRINT DPB MSG
	DB	'The address of the disk parameter block is',SPACHI

	MVI	C,DPBADR
	CALL	BDOS 		;GET DPB ADDR
	CALL	HLHEX		;PRINT DPB ADDR IN HEX
	MVI	A,'H' 
	CALL	HXPRT		;PRINT H
	CALL	CRLFD

	CALL	PRINT 		;PRINT USER MSG
	DB	'The present USER number is',SPACHI
	
	MVI	E,0FFH
	MVI	C,USRCOD
	CALL	BDOS 		;GET USER #

	CALL	HYNIB		;PRINT USER #
	MVI	A,'H' 
	CALL	HXPRT		;PRINT H
	CALL	CRLFD


	LHLD	OSTACK		;RESTORE OLD STACK
	SPHL
	RET

; SUBROUTINES

BINDEC:	PUSH	B		;SAVE REGISTERS
	PUSH	D
	PUSH	H

	LXI	B,0FFF6H
	LXI	D,0FFFFH
BINDC1:	DAD	B
	INX	D
	JC	BINDC1
	LXI	B,0000AH
	DAD	B
	XCHG
	MOV	A,H
	ORA	L
	CNZ	BINDEC
	MOV	A,E
	ADI	030H
	MOV	E,A
	MVI	C,CONOUT
	MOV	E,A
	CALL	BDOS		;PRINT VALUE IN DECIMAL

	POP	H		;RESTORE REGISTERS
	POP	D
	POP	B
	RET


PRINT:	XTHL
	PUSH	D
PRIN1:	MOV	A,M
	MOV	D,A
	ANI	07FH
	MOV	E,A
	PUSH	H
	PUSH	D
	CALL	PCONS
	POP	D
	POP	H
	INX	H
	MVI	A,080H
	ANA	D
	JP	PRIN1
	POP	D
	XTHL
	RET

PCONS:	MVI	C,CONOUT
	JMP	BDOS

WHAT:	LDA	STOR4
	CPI	003H
	JNZ	WHAT2
	MOV	L,E
WHAT1:	MVI	H,ZERO
	RET

WHAT2:	CPI	002H
	JNZ	WHAT3
	MOV	A,E
	RRC
	ANI	07FH
	MOV	L,A
	JMP	WHAT1

WHAT3:	SUI	003H
	MOV	B,A
	XCHG
WHAT4:	DAD	H
	DCR	B
	JNZ	WHAT4
	RET

HLHEX:	MOV	A,H
	CALL	HYNIB
	MOV	A,L
HYNIB:	MOV	C,A
 	RRC
	RRC
	RRC
	RRC
	CALL	LONIB
	MOV	A,C
LONIB:	ANI	00FH
	ADI	030H
	CPI	03AH
	JC	HXPRT
	ADI	007H

HXPRT:	PUSH	B
	PUSH	D
	PUSH	H
	MOV	E,A
	CALL	PCONS
	POP	H
	POP	D
	POP	B
	RET

CRLFD:	CALL	PRINT
	DB	CR,LFHI
	RET

;STORAGE AND STACK LOCATIONS

	DS	2
STOR1	DS	2		
	DS	1EH
OSTACK	DS	2		;OLD STACK
RAMSZ	DS	2
ROMSZ	DS	2
STOR2	DS	1
STOR3	DS	1
STOR4	DS	1
STOR5	DS	1
	DS	41H
STACK	DS	2 		;STACK LOCATION
STPA	DS	2		;TPA ADDRESS STORAGE
SBDOS	DS	2		;BDOS ADDRESS STORAGE

	END
 